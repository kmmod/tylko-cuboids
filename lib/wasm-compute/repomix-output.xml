This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
compute/
  bounding_box.rs
  build_groups.rs
  mod.rs
  parse_csv.rs
  spatial_hash.rs
  types.rs
lib.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="compute/bounding_box.rs">
use crate::compute::types::{Box3D, Cuboid, BOUNDING_BOX_GROUP_ID, X1, X2, Y1, Y2, Z1, Z2};

pub fn compute(cuboids: &[Cuboid]) -> Box3D {
    if cuboids.is_empty() {
        return [BOUNDING_BOX_GROUP_ID, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
    }

    let (min, max) = cuboids
        .iter()
        .fold(([f64::MAX; 3], [f64::MIN; 3]), |(min, max), c| {
            (
                [min[0].min(c[X1]), min[1].min(c[Y1]), min[2].min(c[Z1])],
                [max[0].max(c[X2]), max[1].max(c[Y2]), max[2].max(c[Z2])],
            )
        });

    [
        BOUNDING_BOX_GROUP_ID,
        (min[0] + max[0]) / 2.0,
        (min[1] + max[1]) / 2.0,
        (min[2] + max[2]) / 2.0,
        max[0] - min[0],
        max[1] - min[1],
        max[2] - min[2],
    ]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_single_cuboid() {
        let cuboids = vec![[0.0, 0.0, 0.0, 0.0, 10.0, 20.0, 30.0]];
        let result = compute(&cuboids);
        assert_eq!(result, [-1.0, 5.0, 10.0, 15.0, 10.0, 20.0, 30.0]);
    }

    #[test]
    fn test_multiple_cuboids() {
        let cuboids = vec![
            [0.0, 0.0, 0.0, 0.0, 5.0, 5.0, 5.0],
            [1.0, 10.0, 10.0, 10.0, 20.0, 20.0, 20.0],
        ];
        let result = compute(&cuboids);
        assert_eq!(result, [-1.0, 10.0, 10.0, 10.0, 20.0, 20.0, 20.0]);
    }

    #[test]
    fn test_empty() {
        let cuboids: Vec<Cuboid> = vec![];
        let result = compute(&cuboids);
        assert_eq!(result[0], -1.0);
    }
}
</file>

<file path="compute/build_groups.rs">
use crate::compute::spatial_hash::SpatialHash;
use crate::compute::types::{Box3D, Cuboid, X1, X2, Y1, Y2, Z1, Z2};
use rustc_hash::FxHashMap;

pub fn build_all_groups(cuboids: &[Cuboid], spatial_hash: &SpatialHash) -> Vec<Vec<Box3D>> {
    let n = cuboids.len();
    if n == 0 {
        return Vec::new();
    }

    let mut uf = UnionFind::new(n);

    // Build unions
    for indices in spatial_hash.values() {
        for i in 0..indices.len() {
            for j in (i + 1)..indices.len() {
                let a = indices[i];
                let b = indices[j];
                if are_face_adjacent(&cuboids[a], &cuboids[b]) {
                    uf.union(a, b);
                }
            }
        }
    }

    // Collect groups
    let mut group_map: FxHashMap<usize, Vec<usize>> = FxHashMap::default();
    for i in 0..n {
        group_map.entry(uf.find(i)).or_default().push(i);
    }

    // Build grouped boxes
    group_map
        .into_values()
        .filter(|indices| indices.len() >= 2)
        .enumerate()
        .map(|(group_id, indices)| {
            indices
                .iter()
                .map(|&idx| {
                    let c = &cuboids[idx];
                    let w = c[X2] - c[X1];
                    let h = c[Y2] - c[Y1];
                    let d = c[Z2] - c[Z1];
                    [
                        group_id as f64,
                        c[X1] + w / 2.0,
                        c[Y1] + h / 2.0,
                        c[Z1] + d / 2.0,
                        w,
                        h,
                        d,
                    ]
                })
                .collect()
        })
        .collect()
}

#[inline]
fn are_face_adjacent(a: &Cuboid, b: &Cuboid) -> bool {
    // X-face
    if (a[X2] == b[X1] || b[X2] == a[X1])
        && a[Y2] > b[Y1]
        && b[Y2] > a[Y1]
        && a[Z2] > b[Z1]
        && b[Z2] > a[Z1]
    {
        return true;
    }
    // Y-face
    if (a[Y2] == b[Y1] || b[Y2] == a[Y1])
        && a[X2] > b[X1]
        && b[X2] > a[X1]
        && a[Z2] > b[Z1]
        && b[Z2] > a[Z1]
    {
        return true;
    }
    // Z-face
    if (a[Z2] == b[Z1] || b[Z2] == a[Z1])
        && a[X2] > b[X1]
        && b[X2] > a[X1]
        && a[Y2] > b[Y1]
        && b[Y2] > a[Y1]
    {
        return true;
    }
    false
}

// Union-Find with path compression and union by rank
pub struct UnionFind {
    parent: Vec<usize>,
    rank: Vec<u8>,
}

impl UnionFind {
    pub fn new(n: usize) -> Self {
        Self {
            parent: (0..n).collect(),
            rank: vec![0; n],
        }
    }

    pub fn find(&mut self, x: usize) -> usize {
        if self.parent[x] != x {
            self.parent[x] = self.find(self.parent[x]);
        }
        self.parent[x]
    }

    pub fn union(&mut self, x: usize, y: usize) {
        let px = self.find(x);
        let py = self.find(y);
        if px == py {
            return;
        }

        match self.rank[px].cmp(&self.rank[py]) {
            std::cmp::Ordering::Less => self.parent[px] = py,
            std::cmp::Ordering::Greater => self.parent[py] = px,
            std::cmp::Ordering::Equal => {
                self.parent[py] = px;
                self.rank[px] += 1;
            }
        }
    }
}
</file>

<file path="compute/mod.rs">
pub mod bounding_box;
pub mod build_groups;
pub mod parse_csv;
pub mod spatial_hash;
pub mod types;
</file>

<file path="compute/parse_csv.rs">
use crate::Cuboid;

/// Parse CSV string into vector of cuboids
/// Format: id;x1;y1;z1;x2;y2;z2
pub fn parse(csv: &str) -> Result<Vec<Cuboid>, String> {
    csv.lines()
        .map(str::trim)
        .filter(|line| !line.is_empty())
        .enumerate()
        .map(|(i, line)| parse_line(i + 1, line))
        .collect()
}

fn parse_line(line_num: usize, line: &str) -> Result<Cuboid, String> {
    let parts: Vec<f64> = line
        .split(';')
        .map(|s| s.parse())
        .collect::<Result<_, _>>()
        .map_err(|_| format!("Invalid number in line {line_num}: {line}"))?;

    parts
        .try_into()
        .map_err(|v: Vec<_>| format!("Line {line_num}: expected 7 values, got {}", v.len()))
}
</file>

<file path="compute/spatial_hash.rs">
use crate::compute::types::{Cuboid, X1, X2, Y1, Y2, Z1, Z2};
// Apparently FxHashMap is a lot faster than the standard HashMap for this use case (about 10x times)
// The hash map in std uses SipHash by default, which provides resistance against DOS attacks, but is slow.
use rustc_hash::FxHashMap;

const CELL_SIZE: f64 = 800.0;

pub type SpatialHash = FxHashMap<(i32, i32, i32), Vec<usize>>;

pub fn build_spatial_hash(cuboids: &[Cuboid]) -> SpatialHash {
    let mut hash = SpatialHash::default();

    for (i, c) in cuboids.iter().enumerate() {
        let min_cx = (c[X1] / CELL_SIZE).floor() as i32;
        let min_cy = (c[Y1] / CELL_SIZE).floor() as i32;
        let min_cz = (c[Z1] / CELL_SIZE).floor() as i32;
        let max_cx = ((c[X2] - 1.0) / CELL_SIZE).floor() as i32;
        let max_cy = ((c[Y2] - 1.0) / CELL_SIZE).floor() as i32;
        let max_cz = ((c[Z2] - 1.0) / CELL_SIZE).floor() as i32;

        for cx in min_cx..=max_cx {
            for cy in min_cy..=max_cy {
                for cz in min_cz..=max_cz {
                    hash.entry((cx, cy, cz)).or_default().push(i);
                }
            }
        }
    }

    hash
}
</file>

<file path="compute/types.rs">
/// Box: [groupId, x, y, z, width, height, depth]
pub type Box3D = [f64; 7];

pub const BOUNDING_BOX_GROUP_ID: f64 = -1.0;

/// Indices for Cuboid array
pub const X1: usize = 1;
pub const Y1: usize = 2;
pub const Z1: usize = 3;
pub const X2: usize = 4;
pub const Y2: usize = 5;
pub const Z2: usize = 6;

/// Cuboid: [id, x1, y1, z1, x2, y2, z2]
pub type Cuboid = [f64; 7];
</file>

<file path="lib.rs">
use js_sys::Float64Array;
use wasm_bindgen::prelude::*;

use crate::compute::{
    bounding_box::compute,
    build_groups::build_all_groups,
    parse_csv::parse,
    spatial_hash::{build_spatial_hash, SpatialHash},
    types::{Box3D, Cuboid},
};

mod compute;

#[wasm_bindgen]
pub struct BoxesResult {
    data: Vec<f64>,    // flat: [box0, box1, box2, ...]
    offsets: Vec<u32>, // group start indices: [0, 5, 12, ...] (in box count, not f64 count)
}

#[wasm_bindgen]
impl BoxesResult {
    #[wasm_bindgen(getter)]
    pub fn data(&self) -> Float64Array {
        Float64Array::from(&self.data[..])
    }

    #[wasm_bindgen(getter)]
    pub fn offsets(&self) -> Vec<u32> {
        self.offsets.clone()
    }
}

impl From<Vec<Vec<Box3D>>> for BoxesResult {
    fn from(groups: Vec<Vec<Box3D>>) -> Self {
        let total_boxes: usize = groups.iter().map(|g| g.len()).sum();
        let mut data = Vec::with_capacity(total_boxes * 7);
        let mut offsets = Vec::with_capacity(groups.len() + 1);

        offsets.push(0);
        for group in groups {
            for box3d in group {
                data.extend_from_slice(&box3d);
            }
            offsets.push((data.len() / 7) as u32);
        }

        Self { data, offsets }
    }
}

#[wasm_bindgen]
pub struct CuboidProcessor {
    cuboids: Vec<Cuboid>,
    boxes: Vec<Box3D>,
    spatial_hash: SpatialHash,
}

#[wasm_bindgen]
impl CuboidProcessor {
    #[wasm_bindgen(constructor)]
    pub fn new() -> CuboidProcessor {
        CuboidProcessor {
            cuboids: Vec::new(),
            boxes: Vec::new(),
            spatial_hash: SpatialHash::default(),
        }
    }

    pub fn parse_csv(&mut self, csv: &str) -> String {
        match parse(csv) {
            Ok(cuboids) => {
                self.cuboids = cuboids;
                "CSV parsed successfully".to_string()
            }
            Err(err) => err,
        }
    }

    pub fn compute_bounding_box(&self) -> Float64Array {
        let bbox = compute(&self.cuboids);
        Float64Array::from(&bbox[..])
    }

    pub fn build_spatial_hash(&mut self) {
        self.spatial_hash = build_spatial_hash(&self.cuboids);
    }

    pub fn build_groups(&mut self) -> BoxesResult {
        build_all_groups(&self.cuboids, &self.spatial_hash).into()
    }

    pub fn get_cuboid_count(&self) -> usize {
        self.cuboids.len()
    }
}
</file>

</files>
